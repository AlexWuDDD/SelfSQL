# 锁机制

## 表锁（偏读）

### 特点

偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁定的概率最高，并发度最低

### 案例结论

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。
MySQL的表级锁有两种模式：
表共享读锁（Table Read Lock)
表独占写锁（Table Write Lock）

对MyISAM表进行操作，会有一下情况

1. 对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。
2. 对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写所释放后，才会执行其他进程的读写操作。

***简二言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞***

****此外， MyISAM的读写调度是写优先，这也是myisam不适合做主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使的查询很难得到锁，从而造成永远阻塞**

## 行锁（偏写）

### 特点

偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁：锁定粒度最小，发生锁冲突的概率最低，并发度最高。

InnoDB与MyISAM的最大不同点有两点：

- 支持事务（TRANSACTION）
- 采用了行级锁

#### 事务（Transcation）及其ACID属性

事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。

- 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行。
- 一致性（Consistent）: 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事物的修改，以保持数据的完整性；事务结束时，所有的内部数据机构（如B树索引或双向链表）也都必须是正确的。
- 隔离性（Isolation）: 数据库系统提供一定的隔离机制，保证事物在不受外部并发操作影响的“独立”环境执行。这意味着事物处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性（Durable）: 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

#### 并发事务处理带来的问题

- 更新丢失（Lost Update）: 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事物的存在，就是发生丢失更新问题--最后的更新覆盖了由其他事务所做的更新。如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。

- 脏读（Dirty Reads）：事务A读到了事务B**已修改但尚未提交**的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。

- 不可重复读（Non-Repeatable Reads）： 再次读取以前读过的数据，却发现读出的数据已经发生了改变, 事务A读取到了事务B已经提交的修改数据，不符合隔离性。

- 幻读（Phantom Reads）:一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。

幻读和脏读有点类似：

- 脏读是事务B里面修改了数据
- 幻读是事务B里面新增了数据

#### 事务的隔离级别

|读数据一致性及允许的并发副作用隔离级别|读数据一致性|脏读|不可重复读|幻读|
|-------------------------------|----------|----|--------|---|
|未提交读Read uncommitted|最低级别|是|是|是|
|已提交读Read committed|语句级|否|是|是|
|可重复读|事务级|否|否|是|
|可序列化|最高级别，事务级|否|否|否|

SHOW VARIABLES LIKE 'tx_isolation';

***无索引行锁升级为表锁***

#### 间隙锁危害

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，
InnoDB也会对这个“间隙”加锁，这种哦锁机制就是所谓的间隙锁（Next-Key锁）。

因为Query执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。
间隙锁有一个比较致命的弱点，就是放锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成那锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。

#### 面试题：常考如何锁定一行

```SQL
begin;
select * from table_xxx where xxxx for update;
...
...
...
commit;


```

#### 总结

Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面远远优于MyISAM的表级锁定。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。

但是，Innodb的行级锁定同样也有其脆弱的一面，当哦我们使用不当时，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会差。

#### 如何分析行锁定

```SQL

SHOW STATUS LIKE 'innodb_row_lock%';

```

- Innodb_row_lock_current_waits 当前正在等待锁定的数量
- Innodb_row_lock_time 从系统启动到现在的锁定总时间长度
- Innodb_row_lock_time_avg 每次等待所花平均时间
- Innodb_row_lock_time_max 从系统启动到现在的等待最长的一次所花的时间
- Innodb_row_lock_waits 从系统启动到现在总共等待的次数

比较重要的是

- Innodb_row_lock_time_avg
- Innodb_row_lock_waits
- Innodb_row_lock_time

***尤其是当等待次数很高，而且每次等待时间很长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划**

优化建议：

- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
- 合理设计索引，尽量缩小锁的范围
- 尽可能减少检索条件，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度
- 尽可能低级别事物隔离

## 页锁

开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发读一般。