# 持久化

## rdb(Redis DataBase)

### 是什么

在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久话过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的回复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一个持久化后的数据可能丢失。

### Fork

Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。

### Rdb保存的是dump.rdb文件

#### save 秒钟 写操作次数

RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，默认

- 是1分中内改了1万次
- 或5分钟内改了10次
- 或15分钟内改了1次

#### 禁用

如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以
>save ""

***如果等不及了，需要立即持久话，那么就在写命令之后，执行save命令***

#### stop-writes-on-bgsave-error

如果配置成no,表示你不在乎数据不一致或者其他的手段发现和控制

#### rdbcompression

对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。

#### rdbchecksum

在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样你会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。

#### 命令save或者是bgsave

Save: save时只管保存，其他不管，全部阻塞

bgsave: redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一个成功执行快照的时间

执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义

### 如何恢复

将备份文件（dump.rdb）移动到redis安装目录目录并启动服务即可

#### CONFIG GET dir 获取目录

### 优势

- 适合大规模的数据恢复
- 对数据完整性和一致性要求不高

### 劣势

- 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改
- Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

## aof(Append Only File)

### 是什么

***以日志的形式来记录每个写操作***，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将些指令从前到后执行一次以完成数据的恢复工作

### aof保存的是appendonly.aof文件

### appendfsync

- always: 同步持久化， 每次发生数据变更被立即记录到磁盘，性能较差但数据完整性比较好
- everysec: 出厂默认推荐，异步操作，每秒记录，如果一秒内宕机，有数据丢失
- no 重不同步

### aof启动/修复/恢复

#### 正常恢复

- 启动: 设置Yes 修改默认的appendonly no, 改为yes
- 将有数据的aof文件复制一份保存到对应目录（config get dir）
- 恢复： 重启redis然后重新加载

#### 异常恢复

- 启动: 设置Yes 修改默认的appendonly no, 改为yes
- 修复： redis-check-aof --fix进行修复
- 恢复： 重启redis然后重新加载

### rewrite

#### 是什么

AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阀值时，Redis就会启动aof文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof

#### 重写原理

aof文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后rename）,遍历新进程的内存中数据每条记录有一条set语句，重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。

#### 触发机制

***Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M是触发***

- no-appendfsync-no-rewrite: 重写时是否可以运用appendfsync, 用默认no即可，保证数据安全性

- auto-aof-rewrite-min-size: 设置重写的基准值

- auto-aof-rewrite-percentage: 设置重写的基准值

### 劣势

- 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度较慢于rdb

- aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同

## 总结

- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储
- AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾，redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大
- 只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久话方式
- 同时开启两种持久化方式
    1 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整
    2 RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（APF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的bug,留着作为一个万一的手段。

- 性能建议

因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。

如果enable aof，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写道新文件造成的阻塞几乎是不可避免的，只要硬盘许可，应该适量减少AOF rewrite的频率，AOF重写的基础大小默认值64MB太小了，可以设到5G以上，默认超过原大小100%大小时重写可以改到适当的数值。

如果不enable aof, 仅靠master-slave replication实现高可用性也可以，能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果master/slave同时宕掉，会丢失十几分钟的数据，启动脚本也要比较两个master/salve中的rdb文件，载入较新的那个，新浪微薄就选用了这种架构。